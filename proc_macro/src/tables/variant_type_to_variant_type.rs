use quote::TokenStreamExt;

use super::*;

pub fn run(input_stream: TokenStream1, enum_stream: TokenStream1) -> Result<TokenStream> {
    let table_attrs = parse_table_metas(input_stream)?;
    let input_enum = syn::parse::<Enum<SynMeta, SynMeta>>(enum_stream)?;
    let enum_def = input_enum.to_token_stream();

    let SaneEnum {
        enum_token,
        ident: enum_ident,
        ty: enum_ty,
        generics,
        variants,
    } = sanitize_enum(input_enum)?;

    let vis = Visibility::Public(Default::default());
    let lf = Lifetime::new("'_r", Span::call_site());
    let where_clause = generics.as_pair().1;

    let mod_ident = if let _Some(SettingModName {
        kw: _,
        eq_token: _,
        name,
    }) = table_attrs.mod_name
    {
        name
    } else {
        let mut enum_lower = enum_ident.to_string();
        enum_lower = enum_lower.to_case(Case::Snake);
        Ident::new(&format!("{enum_lower}_variant_type_table"), Span::call_site())
    };

    let table_ident = if let _Some(SettingTypeName {
        kw: _,
        eq_token: _,
        name,
    }) = table_attrs.ty_name
    {
        name
    } else {
        Ident::new(&format!("{enum_ident}VariantTypeTable"), Span::call_site())
    };

    let (gen_params, gen_args, gen_lf_params, gen_lf_args) = {
        let gen_params_list = {
            let mut tokens = generics.stream_params_list();
            if !tokens.is_empty() {
                tokens.append_terminated(std::iter::empty::<TokenStream>(), <Token![,]>::default());
            }

            tokens
        };

        let gen_args_list = {
            let mut tokens = generics.stream_args_list();
            if !tokens.is_empty() {
                tokens.append_terminated(std::iter::empty::<TokenStream>(), <Token![,]>::default());
            }
            tokens
        };

        let (lb, rb) = match &generics {
            _Some(SaneGenerics {
                input:
                    InputGenerics {
                        lb_token,
                        params: _,
                        rb_token,
                    },
                where_clause: _,
            }) => (lb_token, rb_token),
            _None => (&Default::default(), &Default::default()),
        };

        let (gen_params, gen_lf_params) = if !gen_params_list.is_empty() {
            (quote! { #lb #gen_params_list #rb }, quote! { #lb #lf, #gen_params_list #rb })
        } else {
            (Default::default(), quote! { #lb #lf #rb })
        };

        let (gen_args, gen_lf_args) = if !gen_args_list.is_empty() {
            (quote! { #lb #gen_args_list #rb }, quote! { #lb #lf, #gen_args_list #rb })
        } else {
            (Default::default(), quote! { #lb #lf #rb })
        };

        (gen_params, gen_args, gen_lf_params, gen_lf_args)
    };

    let table_ty = if !gen_args.is_empty() {
        quote! { #table_ident::#gen_args }
    } else {
        table_ident.to_token_stream()
    };

    let field_idents = variants
        .iter()
        .map(|var| &var.table_field_ident)
        .collect::<Vec<_>>();

    let var_cfgs = variants
        .iter()
        .map(|var| &var.cfg_attrs)
        .collect::<Vec<_>>();

    let var_tys = variants.iter().map(|var| &var.ty).collect::<Vec<_>>();
    let var_idents = variants.iter().map(|var| &var.ident).collect::<Vec<_>>();

    const MACRO_LINK: &str = "spire_enum_macros::variant_type_table";
    const DOCS_INTRO: &str = "This type was generated by an invocation of the macro [`variant_type_table`](spire_enum_macros::variant_type_table).";

    let table_def = {
        let attrs = table_attrs.syn_metas;

        let docs = docs_tokens(format!(
            "{DOCS_INTRO}\n\n\
             A fixed-size collection that contains exactly one value of each variant of [`{enum_ident}`].\n\
             Variants can be accessed by calling [`get::<VarType>()`]({table_ident}::get) or [`get_mut`]({table_ident}::get_mut).\n\
             For a full list of all methods generated for this type, see the [macro]({MACRO_LINK}) documentation.\n\n\
             This type does not allocate heap memory(can be used in `no_std`)."
        ));
        quote! {
            #docs
            #(#[#attrs])*
            #vis struct #table_ident #gen_params #where_clause {
                #(
                    #var_cfgs
                    pub #field_idents: #var_tys
                ),*
            }
        }
    };

    let enum_ref_ident = Ident::new(&format!("{enum_ident}Ref"), Span::call_site());
    let enum_ref_ty = quote! { #enum_ref_ident::#gen_lf_args };
    let enum_ref_def = {
        let docs = docs_tokens(format!(
            "{DOCS_INTRO}\n\n\
			 An enum that mirrors the variants of [`{enum_ident}`], except this \
			 holds a reference of the variant's type instead of owning their value.\n\n\
			 This enum is used when iterating the type [`{table_ident}`] by-reference (specifically in [`iter`]({table_ident}::iter)."
        ));

        quote! {
            #docs
            #vis #enum_token #enum_ref_ident #gen_lf_params #where_clause {
                #(
                    #var_cfgs
                    #var_idents (&#lf #var_tys)
                ),*
            }
        }
    };

    let enum_mut_ident = Ident::new(&format!("{enum_ident}Mut"), Span::call_site());
    let enum_mut_ty = quote! { #enum_mut_ident::#gen_lf_args };
    let enum_mut_def = {
        let docs = docs_tokens(format!(
            "{DOCS_INTRO}\n\n\
			 An enum that mirrors the variants of [`{enum_ident}`], except this \
			 holds mutable references to the variants instead of owning their values.\n\n\
			 This enum is used when iterating the type [`{table_ident}`] by-mut-reference (specifically in [`iter_mut`]({table_ident}::iter_mut)."
        ));

        quote! {
            #docs
            #vis #enum_token #enum_mut_ident #gen_lf_params #where_clause {
                #(
                    #var_cfgs
                    #var_idents (&#lf mut #var_tys)
                ),*
            }
        }
    };

    let key_trait_ident = Ident::new("__KeyInTable", Span::call_site());
    let key_trait_ty = quote! { #key_trait_ident #gen_args };
    let key_trait_def = {
        quote! {
            #[doc(hidden)]
            pub trait #key_trait_ident #gen_params #where_clause {
                fn __get_in_table<'__a>(table: &'__a #table_ty) -> &'__a Self where Self: '__a;
                fn __get_in_table_mut<'__a>(table: &'__a mut #table_ty) -> &'__a mut Self where Self: '__a;
            }
        }
    };

    let key_in_impls = quote! {
        #(
            #var_cfgs
            #[doc(hidden)]
            impl #gen_params #key_trait_ty for #var_tys #where_clause {
                fn __get_in_table<'__a>(table: &'__a #table_ty) -> &'__a Self where Self: '__a {
                    &table.#field_idents
                }

                fn __get_in_table_mut<'__a>(table: &'__a mut #table_ty) -> &'__a mut Self where Self: '__a {
                    &mut table.#field_idents
                }
            }
        )*
    };

    let len_ident = {
        let table_upper = table_ident.to_string().to_case(Case::Constant);
        Ident::new(&format!("{}_LEN", table_upper), Span::call_site())
    };

    let len_def = length_definition(&len_ident, var_cfgs.iter().cloned());

    let table_impls = {
        let docs_new = docs_tokens(format!(
            "Constructs a new instance of the type.\n\n\
			 Since this table guarantees that it contains exactly one value of each variant of [`{enum_ident}`],\
			 all fields(variants) must be initialized during construction."
        ));

        let docs_get = docs_tokens(format!(
            "Returns a reference to the value of the unique type `Key` that is always present in this table.\n\n\
             Note that [`{key_trait_ident}`] is only implemented for the variants of `[{enum_ident}].\n\n\
             This method will never panic, it is guaranteed at compile time that the table contains the value associated with `Key`."
        ));

        let docs_get_mut = docs_tokens(format!(
            "Returns a mutable reference to the value of the unique type `Key` that is always present in this table.\n\n\
             Note that [`{key_trait_ident}`] is only implemented for the variants of `[{enum_ident}].\n\n\
             This method will never panic, it is guaranteed at compile time that the table contains the value associated with `Key`."
        ));

        let docs_into_iter = docs_tokens(format!(
            "Convert this table into an iterator that yields all fields(variants of [`{enum_ident}`]) that were inside this table.\n\
             - It is guaranteed that each value yielded is a unique variant of the enum [`{enum_ident}`].\n\
             - It is guaranteed that values will be yielded in the exact order they were declared in [`{enum_ident}`] (Top to bottom).\n\
             - The iterator returned does not allocate heap memory, it is merely a fixed-size array with length known at compile time."
        ));

        let docs_iter = docs_tokens(format!(
            "Iterates through references of all fields(variants of [`{enum_ident}`]) inside this table.\n\
             - It is guaranteed that each value yielded is a unique variant of the enum [`{enum_ident}`].\n\
             - It is guaranteed that values will be yielded in the exact order they were declared in [`{enum_ident}`] (Top to bottom).\n\
             - The iterator returned does not allocate heap memory, it is merely a fixed-size array with length known at compile time."
        ));

        let docs_iter_mut = docs_tokens(format!(
            "Iterates through mutable references of all fields(variants of [`{enum_ident}`]) inside this table.\n\
             - It is guaranteed that each value yielded is a unique variant of the enum [`{enum_ident}`].\n\
             - It is guaranteed that values will be yielded in the exact order they were declared in [`{enum_ident}`] (Top to bottom).\n\
             - The iterator returned does not allocate heap memory, it is merely a fixed-size array with length known at compile time."
        ));

        quote! {
            #[allow(unused)]
            #[allow(clippy::too_many_arguments)]
            impl #gen_params #table_ty #where_clause {
                #[allow(clippy::too_many_arguments)]
                #docs_new
                pub const fn new(
                    #(
                        #var_cfgs
                        #field_idents: #var_tys
                    ),*
                ) -> Self {
                    Self {
                        #(
                            #var_cfgs
                            #field_idents
                        ),*
                    }
                }

                #docs_get
                pub fn get<Var: #key_trait_ty>(&self) -> &Var {
                    Var::__get_in_table(self)
                }

                #docs_get_mut
                pub fn get_mut<Var: #key_trait_ty>(&mut self) -> &mut Var {
                    Var::__get_in_table_mut(self)
                }

                #[doc = "Replaces the variant of type `Var`, with the contents of `value`.\n\n\
                         This is shorthand for `*self.get_mut::<Var>() = some_variant;`.\n\
                         This method is provided merely as \"sugar\" for those who aren't \
                         very familiar with dereferencing."]
                pub fn set<Var: #key_trait_ty>(&mut self, value: Var) {
                    *self.get_mut::<Var>() = value;
                }

                #[doc = "Replaces one of the table's fields in a \"untyped\" way.\n\
                         Use this when you want to replace a variable in the table without \
                         having to match on each case of the enum."]
                pub fn set_enum(&mut self, value: #enum_ty) {
                    match value {
                        #(
                            #var_cfgs
                            #enum_ident::#var_idents(__var) => {
                                self.#field_idents = __var;
                            }
                        )*
                    }
                }

                #[allow(clippy::needless_lifetimes)]
                #docs_iter
                pub fn iter<#lf>(&#lf self) -> core::array::IntoIter<#enum_ref_ty, #len_ident> {
                    [
                        #(
                            #var_cfgs
                            #enum_ref_ty::#var_idents(&self.#field_idents)
                        ),*
                    ].into_iter()
                }

                #[allow(clippy::needless_lifetimes)]
                #docs_iter_mut
                pub fn iter_mut<#lf>(&#lf mut self) -> core::array::IntoIter<#enum_mut_ty, #len_ident> {
                    [
                        #(
                            #var_cfgs
                            #enum_mut_ty::#var_idents(&mut self.#field_idents)
                        ),*
                    ].into_iter()
                }
            }

            impl #gen_params IntoIterator for #table_ty #where_clause {
                type Item = #enum_ty;
                type IntoIter = core::array::IntoIter<Self::Item, #len_ident>;

                #docs_into_iter
                fn into_iter(self) -> Self::IntoIter {
                    [
                        #(
                            #var_cfgs
                            <#enum_ty>::#var_idents(self.#field_idents)
                        ),*
                    ].into_iter()
                }
            }

            impl #gen_lf_params IntoIterator for &#lf #table_ty #where_clause {
                type Item = #enum_ref_ty;
                type IntoIter = core::array::IntoIter<Self::Item, #len_ident>;

                #[doc = "See [`iter`](Self::iter)"]
                fn into_iter(self) -> Self::IntoIter { self.iter() }
            }

            impl #gen_lf_params IntoIterator for &#lf mut #table_ty #where_clause {
                type Item = #enum_mut_ty;
                type IntoIter = core::array::IntoIter<Self::Item, #len_ident>;

                #[doc = "See [`iter_mut`](Self::iter_mut)"]
                fn into_iter(self) -> Self::IntoIter { self.iter_mut() }
            }
        }
    };

    Ok(quote! {
        #enum_def

        #[allow(unused_imports)]
        pub(crate) use #mod_ident::#table_ident;

        #[allow(unused_imports)]
        mod #mod_ident {
            use super::*;

            #len_def
            #key_trait_def
            #table_def
            #enum_ref_def
            #enum_mut_def
            #key_in_impls
            #table_impls
        }
    })
}

struct SaneEnum {
    enum_token: Token![enum],
    ident: Ident,
    ty: Type,
    generics: Optional<SaneGenerics>,
    variants: Vec<SaneVariant>,
}

struct SaneVariant {
    cfg_attrs: Any<Attribute<CfgMeta>>,
    ident: Ident,
    table_field_ident: Ident,
    ty: Type,
}

fn sanitize_enum(input: Enum<SynMeta, SynMeta>) -> Result<SaneEnum> {
    let Enum {
        attrs: _,
        vis: _,
        enum_token,
        ident,
        generics,
        where_clause,
        variants,
    } = input;

    let generics = sanitize_generics(generics, where_clause)?;
    let ty = new_ty_maybe_generic(&ident, &generics);

    let variants = variants
        .into_inner()
        .inner
        .into_iter()
        .map(
            |Var {
                 attrs,
                 ident,
                 fields,
                 discriminant: _,
             }| {
                const HELP: &str =
                    "A variant table can only be generated if all variants have exactly one field.";

                let cfg_attrs = parse_cfg_attrs(attrs);

                match fields {
                    VarFields::Named(named) => {
                        if named.len() == 1 {
                            let ty = named.into_inner().inner.into_iter().next().unwrap().ty;
                            Ok(SaneVariant {
                                cfg_attrs,
                                table_field_ident: var_to_field_ident(&ident),
                                ident,
                                ty,
                            })
                        } else {
                            bail!(named => HELP)
                        }
                    }
                    VarFields::Unnamed(unnamed) => {
                        if unnamed.len() == 1 {
                            let ty = unnamed.into_inner().inner.into_iter().next().unwrap().ty;
                            Ok(SaneVariant {
                                cfg_attrs,
                                table_field_ident: var_to_field_ident(&ident),
                                ident,
                                ty,
                            })
                        } else {
                            bail!(unnamed => HELP)
                        }
                    }
                    VarFields::Unit => bail!(fields => HELP),
                }
            },
        )
        .try_collect()?;

    Ok(SaneEnum {
        enum_token,
        ident,
        generics,
        variants,
        ty,
    })
}
