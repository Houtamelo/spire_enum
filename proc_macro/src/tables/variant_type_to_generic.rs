use super::*;

pub fn run(input_stream: TokenStream1, enum_stream: TokenStream1) -> Result<TokenStream> {
	let table_attrs = parse_table_metas(input_stream)?;
	let input_enum = syn::parse::<Enum<SynMeta, SynMeta>>(enum_stream)?;
	let enum_def = input_enum.to_token_stream();

	let SaneEnum {
		ident: enum_ident,
		variants,
	} = sanitize_enum(input_enum)?;

	let vis = Visibility::Public(Default::default());
	let lf = Lifetime::new("'_r", Span::call_site());
	let gen_t = Ident::new("Value", Span::call_site());

	let mod_ident = if let _Some(SettingModName { name, .. }) = table_attrs.mod_name {
		name
	} else {
		let mut enum_lower = enum_ident.to_string();
		enum_lower = enum_lower.to_case(Case::Snake);
		Ident::new(&format!("{enum_lower}_variant_generic_table"), Span::call_site())
	};

	let table_ident = if let _Some(SettingTypeName { name, .. }) = table_attrs.ty_name {
		name
	} else {
		Ident::new(&format!("{enum_ident}VariantGenericTable"), Span::call_site())
	};

	let gen_params = quote! { <#gen_t> };
	let gen_args = &gen_params;

	let gen_lf_params = quote! { <#lf, #gen_t> };
	let gen_lf_args = &gen_lf_params;

	let table_ty = quote! { #table_ident::#gen_args };

	let fields = variants
		.iter()
		.map(|var| &var.table_field_ident)
		.collect::<Vec<_>>();

	const MACRO_LINK: &str = "spire_enum_macros::variant_generic_table";
	const DOCS_INTRO: &str = "This type was generated by an invocation of the macro [`variant_generic_table`](spire_enum_macros::variant_generic_table).";

	let table_def = {
		let attrs = table_attrs.syn_metas;

		let docs = docs_tokens(format!(
			"{DOCS_INTRO}\n\n\
             A fixed-size collection that contains exactly one value of the generic [`{gen_t}`] for each variant of [`{enum_ident}`].\n\
             Values can be accessed by calling [`get::<VarType>()`]({table_ident}::get) or [`get_mut`]({table_ident}::get_mut).\n\
             For a full list of all methods generated for this type, see the [macro]({MACRO_LINK}) documentation.\n\n\
             This type does not allocate heap memory(can be used in `no_std`), though no such guarantee is provided to the generic [`{gen_t}`]."
		));

		quote! {
			#docs
			#(#[#attrs])*
			#vis struct #table_ident<#gen_t> {
				#(pub #fields: #gen_t),*
			}
		}
	};

	let var_idents = variants.iter().map(|var| &var.ident).collect::<Vec<_>>();

	let enum_ref_ident = Ident::new(&format!("{enum_ident}Ref"), Span::call_site());
	let enum_ref_ty = quote! { #enum_ref_ident::#gen_lf_args };
	let enum_ref_def = {
		let docs = docs_tokens(format!(
			"{DOCS_INTRO}\n\n\
			 An enum that mirrors the variant names of [`{enum_ident}`], except this \
			 holds a reference to the generic [`{gen_t}`] instead of owning it.\n\n\
			 This enum is used when iterating the type [`{table_ident}`] by-reference (specifically in [`iter`]({table_ident}::iter)."
		));

		quote! {
			#docs
			#vis enum #enum_ref_ident #gen_lf_params {
				#(#var_idents(&#lf #gen_t)),*
			}
		}
	};

	let enum_mut_ident = Ident::new(&format!("{enum_ident}Mut"), Span::call_site());
	let enum_mut_ty = quote! { #enum_mut_ident::#gen_lf_args };
	let enum_mut_def = {
		let docs = docs_tokens(format!(
			"{DOCS_INTRO}\n\n\
			 An enum that mirrors the variant names of [`{enum_ident}`], except this \
			 holds a mutable reference to the generic [`{gen_t}`] instead of owning it.\n\n\
			 This enum is used when iterating the type [`{table_ident}`] by-mut-reference (specifically in [`iter_mut`]({table_ident}::iter_mut)."
		));

		quote! {
			#docs
			#vis enum #enum_mut_ident #gen_lf_params {
				#(#var_idents(&#lf mut #gen_t)),*
			}
		}
	};

	let enum_own_ident = Ident::new(&format!("{enum_ident}Own"), Span::call_site());
	let enum_own_ty = quote! { #enum_own_ident::#gen_args };
	let enum_own_def = {
		let docs = docs_tokens(format!(
			"{DOCS_INTRO}\n\n\
			 An enum that mirrors the variant names of [`{enum_ident}`], although each variant of this enum \
			 contains the same generic [`{gen_t}`].\n\n\
			 This enum is used when converting the type [`{table_ident}`] into a iterator."
		));

		quote! {
			#docs
			#vis enum #enum_own_ident #gen_params {
				#(#var_idents(#gen_t)),*
			}
		}
	};

	let key_trait_ident = Ident::new("__KeyInTable", Span::call_site());
	let key_trait_ty = &key_trait_ident;
	let key_trait_def = quote! {
		#[doc(hidden)]
		pub trait #key_trait_ident {
			fn __get_in_table<'__a, #gen_t>(table: &'__a #table_ty) -> &'__a #gen_t where #gen_t: '__a;
			fn __get_in_table_mut<'__a, #gen_t>(table: &'__a mut #table_ty) -> &'__a mut #gen_t where #gen_t: '__a;
		}
	};

	let key_in_impls = variants.iter().map(
        |SaneVariant {
            ident: _,
            table_field_ident,
            ty,
            generics: var_generics,
        }| {
            let var_params = var_generics.stream_params();

            quote! {
                #[doc(hidden)]
				impl #var_params #key_trait_ty for #ty {
					fn __get_in_table<'__a, #gen_t>(table: &'__a #table_ty) -> &'__a #gen_t where #gen_t: '__a {
						&table.#table_field_ident
					}
                    fn __get_in_table_mut<'__a, #gen_t>(table: &'__a mut #table_ty) -> &'__a mut #gen_t where #gen_t: '__a {
						&mut table.#table_field_ident
					}
				}
			}
        },
    );

	let length = variants.len();
	let table_impls = {
		let docs_new = docs_tokens(format!(
			"Constructs a new instance of the type.\n\n\
			 Since this table guarantees that it contains exactly one value for each variant of [`{enum_ident}`],\
			 all variants's values must be initialized during construction."
		));

		let docs_get = docs_tokens(format!(
			"Returns a reference to the value associated with the variant's type `Key` that is always present in this table.\n\n\
             Note that [`{key_trait_ident}`] is only implemented for the variants of `[{enum_ident}].\n\n\
             This method will never panic, it is guaranteed at compile time that the table contains the value associated with `Key`."
		));

		let docs_get_mut = docs_tokens(format!(
			"Returns a mutable reference to the value associated with the variant's type `Key` that is always present in this table.\n\n\
             Note that [`{key_trait_ident}`] is only implemented for the variants of `[{enum_ident}].\n\n\
             This method will never panic, it is guaranteed at compile time that the table contains the value associated with `Key`."
		));

		let docs_into_iter = docs_tokens(format!(
			"Convert this table into an iterator that yields all values of the generic [`{gen_t}`], that were mapped to each variant of [`{enum_ident}`].\n\
             - It is guaranteed that values will be yielded in the exact order they were declared in [`{enum_ident}`] (Top to bottom).\n\
             - The iterator returned does not allocate heap memory, it is merely a fixed-size array with length known at compile time."
		));

		let docs_iter = docs_tokens(format!(
			"Iterates through references of all values of the generic [`{gen_t}`], that are mapped to each variant of [`{enum_ident}`].\n\
             - It is guaranteed that values will be yielded in the exact order they were declared in [`{enum_ident}`] (Top to bottom).\n\
             - The iterator returned does not allocate heap memory, it is merely a fixed-size array with length known at compile time."
		));

		let docs_iter_mut = docs_tokens(format!(
			"Iterates through mutable references of all values of the generic [`{gen_t}`], that are mapped to each variant of [`{enum_ident}`].\n\
             - It is guaranteed that values will be yielded in the exact order they were declared in [`{enum_ident}`] (Top to bottom).\n\
             - The iterator returned does not allocate heap memory, it is merely a fixed-size array with length known at compile time."
		));

		quote! {
			#[allow(clippy::too_many_arguments)]
			impl #gen_params #table_ty {
				#[allow(clippy::too_many_arguments)]
				#docs_new
				pub const fn new( #(#fields: #gen_t),* ) -> Self {
					Self { #(#fields),* }
				}

				#[doc = "Constructs a new instance of the type, populating every variant's value with the parameter `__val`"]
				pub fn filled_with(__val: #gen_t) -> Self where #gen_t: Clone {
					Self { #(#fields: __val.clone()),* }
				}

				#docs_get
				pub fn get<Key: #key_trait_ty>(&self) -> &#gen_t {
					Key::__get_in_table::<#gen_t>(self)
				}

				#docs_get_mut
				pub fn get_mut<Key: #key_trait_ty>(&mut self) -> &mut #gen_t {
					Key::__get_in_table_mut::<#gen_t>(self)
				}

				#[allow(clippy::needless_lifetimes)]
				#docs_iter
				pub fn iter<#lf>(&#lf self) -> core::array::IntoIter<#enum_ref_ty, #length> {
					[
						#(#enum_ref_ty::#var_idents(&self.#fields)),*
					].into_iter()
				}

				#[allow(clippy::needless_lifetimes)]
				#docs_iter_mut
				pub fn iter_mut<#lf>(&#lf mut self) -> core::array::IntoIter<#enum_mut_ty, #length> {
					[
						#(#enum_mut_ty::#var_idents(&mut self.#fields)),*
					].into_iter()
				}
			}

			impl #gen_params IntoIterator for #table_ty {
				type Item = #enum_own_ty;
				type IntoIter = core::array::IntoIter<Self::Item, #length>;

				#docs_into_iter
				fn into_iter(self) -> Self::IntoIter {
					[
						#(#enum_own_ty::#var_idents(self.#fields)),*
					].into_iter()
				}
			}

			impl #gen_lf_params IntoIterator for &#lf #table_ty {
				type Item = #enum_ref_ty;
				type IntoIter = core::array::IntoIter<Self::Item, #length>;

				#[doc = "See [`iter`](Self::iter)"]
				fn into_iter(self) -> Self::IntoIter { self.iter() }
			}

			impl #gen_lf_params IntoIterator for &#lf mut #table_ty {
				type Item = #enum_mut_ty;
				type IntoIter = core::array::IntoIter<Self::Item, #length>;

				#[doc = "See [`iter_mut`](Self::iter_mut)"]
				fn into_iter(self) -> Self::IntoIter { self.iter_mut() }
			}
		}
	};

	Ok(quote! {
		#enum_def
		pub(crate) use #mod_ident::#table_ident;

		mod #mod_ident {
			use super::*;

			#key_trait_def
			#table_def
			#enum_ref_def
			#enum_mut_def
			#enum_own_def
			#(#key_in_impls)*
			#table_impls
		}
	})
}

struct SaneEnum {
	ident: Ident,
	variants: Vec<SaneVariant>,
}

struct SaneVariant {
	ident: Ident,
	table_field_ident: Ident,
	ty: Type,
	generics: Optional<SaneGenerics>,
}

fn sanitize_enum(input: Enum<SynMeta, SynMeta>) -> Result<SaneEnum> {
	let Enum {
		attrs: _,
		vis: _,
		enum_token: _,
		ident,
		generics: enum_generics,
		where_clause,
		variants,
	} = input;

	let sane_enum_generics = sanitize_generics(enum_generics, where_clause)?;

	let variants = variants
		.into_inner()
		.into_iter()
		.map(|Var { ident, fields, .. }| {
			const HELP: &str =
				"A variant table can only be generated if all variants have exactly one field.";

			let generics = generics_needed_by_variant(&fields, &sane_enum_generics);

			match fields {
				VarFields::Named(named) => {
					if named.len() == 1 {
						let ty = named.into_inner().into_iter().next().unwrap().ty;
						Ok(SaneVariant {
							table_field_ident: var_to_field_ident(&ident),
							ident,
							ty,
							generics,
						})
					} else {
						bail!(named => HELP)
					}
				}
				VarFields::Unnamed(unnamed) => {
					if unnamed.len() == 1 {
						let ty = unnamed.into_inner().into_iter().next().unwrap().ty;
						Ok(SaneVariant {
							table_field_ident: var_to_field_ident(&ident),
							ident,
							ty,
							generics,
						})
					} else {
						bail!(unnamed => HELP)
					}
				}
				VarFields::Unit => bail!(fields => HELP),
			}
		})
		.try_collect()?;

	Ok(SaneEnum { ident, variants })
}
